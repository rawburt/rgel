#!/usr/bin/env ruby

# DISCLAIMER: Generated by AI via CoPilot using Claude Sonnet 4.5

require "open3"
require "optparse"

class TestRunner
  RESET = "\e[0m"
  GREEN = "\e[32m"
  RED = "\e[31m"
  YELLOW = "\e[33m"
  BUILD = "_build/default/bin/main.exe"

  def initialize(options = {})
    @verbose = options[:verbose]
    @filter = options[:filter]
    @passed = 0
    @failed = 0
    @skipped = 0
    @start_time = Time.now
  end

  def run
    unless build
      puts "#{RED}Build failed#{RESET}"
      exit 1
    end

    files = collect_test_files
    puts "Running #{files.length} tests...\n\n"

    files.each { |file| run_test(file) }

    print_summary
    exit(@failed > 0 ? 1 : 0)
  end

  private

  def build
    puts "Building project..."
    system("dune build")
  end

  def collect_test_files
    all_files = Dir.glob("tests/**/*.rgel")
    return all_files unless @filter
    all_files.select { |f| f.include?(@filter) }
  end

  def run_test(file)
    metadata = parse_metadata(file)

    if metadata[:skip]
      skip(file, metadata[:skip_reason])
      return
    end

    stdout, stderr, status = Open3.capture3("#{BUILD} -entry main -quickjs #{file}")

    if matches_expectation?(metadata, stdout, stderr, status)
      pass(file)
    else
      fail(file, metadata, stdout, stderr, status)
    end
  rescue => e
    fail(file, metadata, "Exception: #{e.message}", "", nil)
  end

  def parse_metadata(file)
    lines = File.readlines(file).first(5)

    metadata = {
      skip: false,
      skip_reason: "",
      result: "success",
      stdout: "",
      stdout_type: :literal,
      stderr: "",
      stderr_type: :literal
    }

    lines.each do |line|
      next unless line.start_with?("#")

      if line.include?("skip")
        metadata[:skip] = true
        metadata[:skip_reason] = line.split("skip").last&.strip || ""
        return metadata
      elsif line.include?("expect:")
        result = line.split(":", 2).last&.strip
        metadata[:result] = result if result && !result.empty?
      elsif line.include?("expect-stdout-regex:")
        metadata[:stdout_type] = :regex
        metadata[:stdout] = line.split(":", 2).last&.strip || ""
      elsif line.include?("expect-stdout:")
        metadata[:stdout_type] = :literal
        metadata[:stdout] = line.split(":", 2).last&.strip || ""
      elsif line.include?("expect-stderr-regex:")
        metadata[:stderr_type] = :regex
        metadata[:stderr] = line.split(":", 2).last&.strip || ""
      elsif line.include?("expect-stderr:")
        metadata[:stderr_type] = :literal
        metadata[:stderr] = line.split(":", 2).last&.strip || ""
      end
    end

    metadata
  rescue => e
    puts "#{YELLOW}Warning: Failed to parse metadata for #{file}: #{e.message}#{RESET}"
    metadata
  end

  def matches_expectation?(metadata, stdout, stderr, status)
    expected_success = metadata[:result] == "success"
    actual_success = status.success?

    return false if expected_success != actual_success

    # Check stdout if specified
    if !metadata[:stdout].empty?
      matches = check_output(stdout, metadata[:stdout], metadata[:stdout_type])
      return false unless matches
    end

    # Check stderr if specified
    if !metadata[:stderr].empty?
      matches = check_output(stderr, metadata[:stderr], metadata[:stderr_type])
      return false unless matches
    end

    true
  end

  def check_output(actual, expected, match_type)
    if match_type == :regex
      begin
        actual.strip =~ Regexp.new(expected)
      rescue RegexpError => e
        puts "#{YELLOW}Invalid regex pattern '#{expected}': #{e.message}#{RESET}"
        false
      end
    else
      actual.include?(expected)
    end
  end

  def pass(file)
    @passed += 1
    puts "#{GREEN}✓ #{file}#{RESET}"
  end

  def fail(file, metadata, stdout, stderr, status)
    @failed += 1
    puts "#{RED}✗ #{file}#{RESET}"

    if @verbose
      puts "  Expected: #{metadata[:result]}"
      puts "  Expected stdout: #{metadata[:stdout]}" unless metadata[:stdout].empty?
      puts "  Expected stderr: #{metadata[:stderr]}" unless metadata[:stderr].empty?
      puts "  Actual: #{status&.success? ? 'success' : 'error'}"
      puts "  Stdout: #{stdout.strip}"
      puts "  Stderr: #{stderr.strip}"
      puts
    end
  end

  def skip(file, reason)
    @skipped += 1
    puts "#{YELLOW}⊘ #{file}#{reason.empty? ? '' : " (#{reason})"}#{RESET}"
  end

  def print_summary
    duration = Time.now - @start_time
    puts "\n" + "=" * 60
    puts "Test Summary:"
    puts "  #{GREEN}Passed:#{RESET}  #{@passed}"
    puts "  #{RED}Failed:#{RESET}  #{@failed}"
    puts "  #{YELLOW}Skipped:#{RESET} #{@skipped}"
    puts "  Duration: #{duration.round(2)}s"
    puts "=" * 60
  end
end

# CLI
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: ruby testrunner.rb [options]"

  opts.on("-v", "--verbose", "Show detailed output for failures") do
    options[:verbose] = true
  end

  opts.on("-f", "--filter PATTERN", "Run only tests matching pattern") do |pattern|
    options[:filter] = pattern
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end.parse!

TestRunner.new(options).run
