#!/usr/bin/env ruby

# DISCLAIMER: Generated by AI via CoPilot using Claude Sonnet 4.5

require "open3"
require "optparse"

class TestRunner
  RESET = "\e[0m"
  GREEN = "\e[32m"
  RED = "\e[31m"
  YELLOW = "\e[33m"
  BUILD = "_build/default/bin/main.exe"

  def initialize(options = {})
    @verbose = options[:verbose]
    @filter = options[:filter]
    @passed = 0
    @failed = 0
    @skipped = 0
    @start_time = Time.now
  end

  def run
    unless build
      puts "#{RED}Build failed#{RESET}"
      exit 1
    end

    files = collect_test_files
    puts "Running #{files.length} tests...\n\n"

    files.each { |file| run_test(file) }

    print_summary
    exit(@failed > 0 ? 1 : 0)
  end

  private

  def build
    puts "Building project..."
    system("dune build")
  end

  def collect_test_files
    all_files = Dir.glob("tests/**/*.rgel")
    return all_files unless @filter
    all_files.select { |f| f.include?(@filter) }
  end

  def run_test(file)
    metadata = parse_metadata(file)

    if metadata[:skip]
      skip(file, metadata[:skip_reason])
      return
    end

    stdout, status = Open3.capture2("#{BUILD} -entry main -quickjs #{file}")

    if matches_expectation?(metadata, stdout, status)
      pass(file)
    else
      fail(file, metadata, stdout, status)
    end
  rescue => e
    fail(file, metadata, "Exception: #{e.message}", nil)
  end

  def parse_metadata(file)
    lines = File.readlines(file).first(3)

    metadata = {
      skip: false,
      skip_reason: "",
      result: "success",
      output: ""
    }

    if lines[0]&.include?("skip")
      metadata[:skip] = true
      metadata[:skip_reason] = lines[0].split("skip").last&.strip || ""
      return metadata
    end

    metadata[:result] = lines[0]&.split(":")&.last&.strip || "success"
    metadata[:output] = lines[1]&.split(":")&.last&.strip || ""

    metadata
  rescue => e
    puts "#{YELLOW}Warning: Failed to parse metadata for #{file}: #{e.message}#{RESET}"
    metadata
  end

  def matches_expectation?(metadata, stdout, status)
    expected_success = metadata[:result] == "success"
    actual_success = status.success?

    return false if expected_success != actual_success

    return true if metadata[:output].empty?

    begin
      stdout.strip =~ Regexp.new(metadata[:output])
    rescue RegexpError => e
      puts "#{YELLOW}Invalid regex pattern '#{metadata[:output]}': #{e.message}#{RESET}"
      false
    end
  end

  def pass(file)
    @passed += 1
    puts "#{GREEN}✓ #{file}#{RESET}"
  end

  def fail(file, metadata, stdout, status)
    @failed += 1
    puts "#{RED}✗ #{file}#{RESET}"

    if @verbose
      puts "  Expected: #{metadata[:result]} with output matching: #{metadata[:output]}"
      puts "  Actual: #{status&.success? ? 'success' : 'error'}"
      puts "  Output: #{stdout.strip}"
      puts
    end
  end

  def skip(file, reason)
    @skipped += 1
    puts "#{YELLOW}⊘ #{file}#{reason.empty? ? '' : " (#{reason})"}#{RESET}"
  end

  def print_summary
    duration = Time.now - @start_time
    puts "\n" + "=" * 60
    puts "Test Summary:"
    puts "  #{GREEN}Passed:#{RESET}  #{@passed}"
    puts "  #{RED}Failed:#{RESET}  #{@failed}"
    puts "  #{YELLOW}Skipped:#{RESET} #{@skipped}"
    puts "  Duration: #{duration.round(2)}s"
    puts "=" * 60
  end
end

# CLI
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: ruby testrunner.rb [options]"

  opts.on("-v", "--verbose", "Show detailed output for failures") do
    options[:verbose] = true
  end

  opts.on("-f", "--filter PATTERN", "Run only tests matching pattern") do |pattern|
    options[:filter] = pattern
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end.parse!

TestRunner.new(options).run
